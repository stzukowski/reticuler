
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// INITIALISATION
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
verbosity = 0;

real time0=clock();

// Adaptation around the tip
func real tipfield( real X, real Y, real sigma)
{
real rr=((x-X)^2 + (y-Y)^2)^0.5;
real err=0;
if (rr>0.99*sigma & rr<1.01*sigma)
    err=1;
return err;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// BUILDING MESH
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

real buildTime0=clock();

border box0(t=0, 1){x=2+t*(0);y=0+t*(50); label=999;}
border box1(t=0, 1){x=2+t*(-2);y=50+t*(0); label=3;}
border box2(t=0, 1){x=0+t*(0);y=50+t*(-50); label=998;}
border box3(t=0, 1){x=0+t*(0.49);y=0+t*(0); label=1;}
border box4(t=0, 1){x=0.49+t*(1);y=0+t*(0); label=1;}
border box5(t=0, 1){x=1.49+t*(0.01);y=0+t*(0); label=1;}
border box6(t=0, 1){x=1.5+t*(0.01);y=0+t*(0); label=1;}
border box7(t=0, 1){x=1.51+t*(0.49);y=0+t*(0); label=1;}
border tip0(t=0, 1){x=0.5+0.01*cos(t*pi);y=0.01+0.01*sin(t*pi); label=1;}
border branch0connection0side0(t=0, 1){x=0.51+t*(0);y=0+t*(0.01); label=1;}
border branch0connection0side1(t=0, 1){x=0.49+t*(0);y=0.01+t*(-0.01); label=1;}
border tip1(t=0, 1){x=1.5+0.01*cos(t*pi);y=0.01+0.01*sin(t*pi); label=1;}
border branch1connection0side0(t=0, 1){x=1.51+t*(0);y=0+t*(0.01); label=1;}
border branch1connection0side1(t=0, 1){x=1.49+t*(0);y=0.01+t*(-0.01); label=1;}
func PBC=[[998,y],[999,y]];
mesh Th = buildmesh( box0(25) + box1(1) + box2(25) + box3(1) + box4(1) + box5(1) + box6(1) + box7(1) + tip0(100) + branch0connection0side0(1) + branch0connection0side1(1) + tip1(100) + branch1connection0side0(1) + branch1connection0side1(1) , fixedborder=true);

real buildTime=clock() - buildTime0;
// plot(Th, wait=true);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DEFINING MOBILITY
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int indRegionOut=Th(1.8,45.0).region;


int indRegion0 = Th(0.5, 0.01).region;
int indRegion1 = Th(1.5, 0.01).region;
fespace Vh0(Th, P0, periodic=PBC);
Vh0 mobility = 1*(region==indRegionOut) + 10000.0*(region==indRegion0 || region==indRegion1);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DEFINING PROBLEM AND equation TO SOLVE
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

fespace Vh(Th,P2, periodic=PBC);
Vh u,v;

problem potential(u,v,solver=sparsesolver)=
         int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v))
                    // -int1d(Th,3)(v)  // constant flux
                    +on(3,u=0) // constant field
                    // -int2d(Th)(v) // rain in domain
                    +on(1,u=1);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ADAPTING THE MESH AND SOLVING FOR THE FIELD
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        

// First adaptation
real firstAdaptTime0=clock();
// Th = adaptmesh(Th,5.*tipfield(X,Y,3.*R,nbTips),nbvx=500000,nbsmooth=100,iso=true);
Th = adaptmesh(Th,1,nbvx=500000,hmax=0.1,nbsmooth=100,iso=true,ratio=1.8);
real firstAdaptTime=clock() - firstAdaptTime0;
// plot(Th, wait=true);

// Solving the problem for the first time
real firstRunTime0=clock();
potential;
// cout<<"First solve completed."<<endl;
real firstRunTime=clock() - firstRunTime0;

// Adaptation loop
real adaptTime0=clock();
// cout << endl << endl << "Adaptation..." << endl;
real error=0.01;
for(int i=0;i<3;i++){
Th=adaptmesh(Th, u, err=error, hmax=0.01, nbvx=500000, periodic=PBC, verbosity=0, keepbackvertices=1); // Adapting mesh according to the first solution
u=u;
error=error/2;
potential; // Solving one more time with adapted mesh
}
// cout << "Problem solved." << endl;
// plot(u, wait=true, fill=true);

real adaptTime=clock() - adaptTime0;
