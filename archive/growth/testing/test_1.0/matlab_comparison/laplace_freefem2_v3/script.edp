
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// INITIALISATION
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
verbosity = 0;

real time0=clock();

// Defining the base vectors of the analytical field around a tip
func real BaseVector(int nf, complex zf)
{
  real result=0;

  if (nf%2==0) 
    result = -imag(zf^(nf/2.));
  else 
    result = real(zf^(nf/2.));
  return result;
}

// Adaptation around the tip
func real tipfield( real[int] X, real[int] Y,real sigma,int nTips)
{
real err=0;
for(int i=0;i<nTips;i++)
	{
		real rsq=(x-X(i))^2 + (y-Y(i))^2;

		if (rsq==0)
			err+=1-erf(1);
		else //if (rsq<2.*square(sigma))
			err+=1 - 0.3*erf(1) + 0.3*erf(sqrt(rsq/(2*sigma^2)));
		// else
		//	err+=1;
	}
return err;
}

// Projection of a mesh around the tip
func int inCircle (real x, real y, real R)
{
    if (x^2+y^2<R^2) return 1;
    else return 0;
}

// Counting vertices in the circle around the tip
real x0=0., y0=0.;
func int[int] countNvAroundTips (real R, mesh Th, int nbVertices, int nbTips, real[int] X, real[int] Y)
{
	int[int] nvAroundTips(nbTips);
	for(int i=0;i<nbTips;++i)
	{
		x0=X(i);
		y0=Y(i);
		int nvAroundTip = 0;
		for (int i = 0; i < nbVertices; i++)
			if ((x0-Th(i).x)^2 + (y0-Th(i).y)^2 < R^2) 
				nvAroundTip += 1;		
		nvAroundTips(i) = nvAroundTip;
	};

	return nvAroundTips;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// BUILDING MESH
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

real buildTime0=clock();

border box0(t=0, 1){x=2.000000000000+t*(0.000000000000);y=0.000000000000+t*(50.000000000000); label=2.000000000000;}
border box1(t=0, 1){x=2.000000000000+t*(-2.000000000000);y=50.000000000000+t*(0.000000000000); label=3.000000000000;}
border box2(t=0, 1){x=0.000000000000+t*(0.000000000000);y=50.000000000000+t*(-50.000000000000); label=2.000000000000;}
border box3(t=0, 1){x=0.000000000000+t*(1.500000000000);y=0.000000000000+t*(0.000000000000); label=1.000000000000;}
border box4(t=0, 1){x=1.500000000000+t*(0.500000000000);y=0.000000000000+t*(0.000000000000); label=1.000000000000;}
border branch0connection0(t=0, 1){x=1.500000000000+t*(0.000000000000);y=0.000000000000+t*(0.010000000000); label=1;}
border branch0connection1(t=0, 1){x=1.500000000000+t*(-0.000003708001);y=0.010000000000+t*(0.009999999313); label=1;}
border branch0connection2(t=0, 1){x=1.499996291999+t*(0.000000878750);y=0.019999999313+t*(0.009999999961); label=1;}
border branch0connection3(t=0, 1){x=1.499997170749+t*(-0.000000756250);y=0.029999999274+t*(0.009999999955); label=1;}

mesh Th = buildmesh( box0(25) + box1(1) + box2(25) + box3(1) + box4(1) + branch0connection0(1) + branch0connection1(1) + branch0connection2(1) + branch0connection3(1) );

real buildTime=clock() - buildTime0;
// plot(Th, wait=true);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// TIP INFORMATION
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int nbTips=1; 
real[int] angle(nbTips);
real[int] X(nbTips); 
real[int] Y(nbTips);

X(0)=1.499996414499;
Y(0)=0.039999999229;
angle(0)=1.570871951819;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DEFINING PROBLEM AND equation TO SOLVE
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

fespace Vh(Th,P2);
Vh u,v;

problem potential(u,v,solver=sparsesolver)=
         int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v))
             -int1d(Th,3)(v)  // constant flux
			 // +on(3,u=50) // constant field
			 // -int2d(Th)(v) // rain in domain
             +on(1,u=0);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ADAPTING THE MESH AND SOLVING FOR THE FIELD
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        

// counting cells around the tips
real R=0.01; // circle around the tip over which field is integrated
int[int] nvAroundTips = countNvAroundTips (3.*R, Th, Th.nv, nbTips, X, Y);

// First adaptation
real firstAdaptTime0=clock();
// Th = adaptmesh(Th,5.*tipfield(X,Y,3.*R,nbTips),nbvx=500000,nbsmooth=100,iso=true);
Th = adaptmesh(Th,1,nbvx=500000,hmax=0.1,nbsmooth=100,iso=true,ratio=1.8);
real firstAdaptTime=clock() - firstAdaptTime0;
// plot(Th, wait=true);

// Solving the problem for the first time
real firstRunTime0=clock();
potential;
// cout<<"First solve completed."<<endl;
real firstRunTime=clock() - firstRunTime0;

// Adaptation loop
real adaptTime0=clock();
// cout << endl << endl << "Adaptation..." << endl;
fespace Vh0(Th,P0);
Vh0 h=1;
real error=0.02;
int adaptCounter=1;
while(nvAroundTips.min < 250 || adaptCounter<=3)
{
	// cout << "Adaptation step: " << adaptCounter << ", h[].min = " << h[].min;
	// cout << ", nvAroundTip.min = " << nvAroundTips.min << endl;
	potential;
	Th=adaptmesh(Th,[u, 20.*tipfield(X,Y,3.*R,nbTips)],err=error,nbvx=1000000,iso=true,ratio=2,hmin=1e-5);
	error = 0.5*error;
	u=u;
	h=hTriangle; // the triangle size
	nvAroundTips = countNvAroundTips (3.*R, Th, Th.nv, nbTips, X, Y);
	adaptCounter++;
}

// cout << endl << "Adaptation finished." << " h[].min = " << h[].min;
// cout << ", nvAroundTip.min = " << nvAroundTips.min << endl;

// solving with adapted mesh
potential;
// cout << "Problem solved." << endl;
// plot(u, wait=true, fill=true);

real adaptTime=clock() - adaptTime0;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// INTEGRATING THE FIELD TO GET a_i COEFFICIENTS
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        
real coeffTime0=clock();
// cout << endl << endl << "Finding the Tip coefficients..." << endl;

mesh Ph;
real[int] a(3); // list of coefficients of the expansion
int exponant=2; // precision of the exponential
// ofstream freefemOutput("{file_name}");

cout << "kopytko ";
for(int i=0;i<nbTips;++i)
{
    // cout << "Processing Tip " << i << " ";   
    x0=X(i);y0=Y(i);
    // cout << "(x0, y0) = (" << x0 << ", " <<y0<< "), angle = " << angle(i) << endl;

	// cout << "Projecting... Th.nv = " << Th.nv;
    Ph=trunc(Th,(sqrt((x-x0)^2+(y-y0)^2) < 3*R)); 
	// cout << ", Ph.nv = " << Ph.nv << endl;

    for(int order=1; order<=a.n; ++order){ 
        a[order-1]=
        int2d(Ph)( u*exp(-(sqrt((x-x0)^2 + (y-y0)^2)/R)^exponant)
		*BaseVector(order,exp(-angle(i)*1i)*( (x-x0) + (y-y0)*1i) ) ) /
        (int2d(Ph)(exp(-(sqrt((x-x0)^2 + (y-y0)^2)/R)^exponant)
		*square(BaseVector(order,exp(-angle(i)*1i)*( (x-x0) + (y-y0)*1i) ) )));

		cout << a[order-1] << ",";
        // cout << "a(" << order << ") = " << a[order-1] << endl;
    }
	// freefemOutput << Th.nv << " ";
	// freefemOutput << Ph.nv << " ";
	// freefemOutput << adaptCounter << " ";

	// cout << endl;
};

// cout << endl << endl << "Building mesh took: " << buildTime; 
// cout << endl << "First adapt took: " << firstAdaptTime; 
// cout << endl << "First run took: " << firstRunTime; 
// cout << endl << "Adaptation took: " << adaptTime; 
// cout << endl << "Calculating coefficients took: " << clock()- coeffTime0;
// cout << endl << "Total time: " << clock()-time0 << endl << endl;
