
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// INITIALISATION
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
verbosity = 0;

real time0=clock();

// Defining the base vectors of the analytical field around a tip
func real BaseVector(int nf, complex zf)
{
  real result=0;

  if (nf%2==0) 
    result = -imag(zf^(nf/2.));
  else 
    result = real(zf^(nf/2.));
  return result;
}

// Adaptation around the tip
func real tipfield( real[int] X, real[int] Y,real sigma,int nTips)
{
real err=0;
for(int i=0;i<nTips;i++)
	{
		real rsq=(x-X(i))^2 + (y-Y(i))^2;

		if (rsq==0)
			err+=1-erf(1);
		else //if (rsq<2.*square(sigma))
			err+=1 - 0.3*erf(1) + 0.3*erf(sqrt(rsq/(2*sigma^2)));
		// else
		//	err+=1;
	}
return err;
}

// Projection of a mesh around the tip
func int inCircle (real x, real y, real R)
{
    if (x^2+y^2<R^2) return 1;
    else return 0;
}

// Counting vertices in the circle around the tip
real x0=0., y0=0.;
func int[int] countNvAroundTips (real R, mesh Th, int nbVertices, int nbTips, real[int] X, real[int] Y)
{
	int[int] nvAroundTips(nbTips);
	for(int i=0;i<nbTips;++i)
	{
		x0=X(i);
		y0=Y(i);
		int nvAroundTip = 0;
		for (int i = 0; i < nbVertices; i++)
			if ((x0-Th(i).x)^2 + (y0-Th(i).y)^2 < R^2) 
				nvAroundTip += 1;		
		nvAroundTips(i) = nvAroundTip;
	};

	return nvAroundTips;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// BUILDING MESH
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

real buildTime0=clock();

border box0(t=0, 1){x=2.0+t*(0.0);y=0.0+t*(50.0); label=2;}
border box1(t=0, 1){x=2.0+t*(-2.0);y=50.0+t*(0.0); label=3;}
border box2(t=0, 1){x=0.0+t*(0.0);y=50.0+t*(-50.0); label=2;}
border box3(t=0, 1){x=0.0+t*(1.5);y=0.0+t*(0.0); label=1;}
border box4(t=0, 1){x=1.5+t*(0.5);y=0.0+t*(0.0); label=1;}
border branch0connection0(t=0, 1){x=1.5+t*(0.0);y=0.0+t*(0.01); label=1;}
border branch0connection1(t=0, 1){x=1.5+t*(-3.7080007222467515e-06);y=0.01+t*(0.009999999312536508); label=1;}
border branch0connection2(t=0, 1){x=1.4999962919992778+t*(-1.5490005462748258e-06);y=0.019999999312536508+t*(0.009999999880029864); label=1;}
border branch0connection3(t=0, 1){x=1.4999947429987315+t*(-1.3805005745215482e-06);y=0.029999999192566372+t*(0.009999999904710906); label=1;}
border branch0connection4(t=0, 1){x=1.499993362498157+t*(-8.492505141344253e-07);y=0.03999999909727728+t*(0.009999999963938674); label=1;}
border branch0connection5(t=0, 1){x=1.4999925132476428+t*(1.075749500589751e-06);y=0.04999999906121595+t*(0.009999999942138155); label=1;}
border branch0connection6(t=0, 1){x=1.4999935889971434+t*(-9.112505956476724e-07);y=0.05999999900335411+t*(0.009999999958481123); label=1;}
border branch0connection7(t=0, 1){x=1.4999926777465478+t*(-4.42550054402524e-06);y=0.06999999896183523+t*(0.009999999020747205); label=1;}
border branch0connection8(t=0, 1){x=1.4999882522460037+t*(-3.016000629463278e-06);y=0.07999999798258244+t*(0.009999999545187002); label=1;}
border branch0connection9(t=0, 1){x=1.4999852362453743+t*(-4.170000557968123e-06);y=0.08999999752776944+t*(0.00999999913055473); label=1;}
border branch0connection10(t=0, 1){x=1.4999810662448163+t*(-6.4530003009988235e-06);y=0.09999999665832417+t*(0.009999997917939138); label=1;}
border branch0connection11(t=0, 1){x=1.4999746132445153+t*(-5.236501293470752e-06);y=0.1099999945762633+t*(0.009999998628952622); label=1;}
border branch0connection12(t=0, 1){x=1.4999693767432218+t*(-9.76700011023901e-06);y=0.11999999320521593+t*(0.009999995230284303); label=1;}
border branch0connection13(t=0, 1){x=1.4999596097431116+t*(-1.2052248899552254e-05);y=0.12999998843550023+t*(0.009999992737162178); label=1;}
border branch0connection14(t=0, 1){x=1.499947557494212+t*(-9.318250565604203e-06);y=0.1399999811726624+t*(0.00999999565850937); label=1;}
border branch0connection15(t=0, 1){x=1.4999382392436464+t*(-1.9459990434178565e-05);y=0.14999997683117178+t*(0.009999981065420688); label=1;}
border branch0connection16(t=0, 1){x=1.4999187792532123+t*(-2.29474827035947e-05);y=0.15999995789659247+t*(0.009999973670617224); label=1;}
border branch0connection17(t=0, 1){x=1.4998958317705087+t*(-2.822296652382761e-05);y=0.1699999315672097+t*(0.009999960173128708); label=1;}
border branch0connection18(t=0, 1){x=1.4998676088039848+t*(-3.464543644771112e-05);y=0.1799998917403384+t*(0.009999939984506573); label=1;}
border branch0connection19(t=0, 1){x=1.4998329633675371+t*(-4.1502888191491394e-05);y=0.18999983172484497+t*(0.009999913875142707); label=1;}
border branch0connection20(t=0, 1){x=1.4997914604793456+t*(-4.618059331651381e-05);y=0.19999974559998768+t*(0.009999893367071522); label=1;}
border branch0connection21(t=0, 1){x=1.4997452798860291+t*(-4.992430030248407e-05);y=0.2099996389670592+t*(0.009999875377435435); label=1;}
border branch0connection22(t=0, 1){x=1.4996953555857266+t*(-5.589421755014534e-05);y=0.21999951434449463+t*(0.009999843790602148); label=1;}
border branch0connection23(t=0, 1){x=1.4996394613681765+t*(-6.471455849998975e-05);y=0.22999935813509678+t*(0.00999979059910347); label=1;}
border branch0connection24(t=0, 1){x=1.4995747468096765+t*(-7.58212854459206e-05);y=0.23999914873420025+t*(0.009999712552502371); label=1;}
border branch0connection25(t=0, 1){x=1.4994989255242306+t*(-8.832661576341216e-05);y=0.24999886128670262+t*(0.009999609912838991); label=1;}
border branch0connection26(t=0, 1){x=1.4994105989084672+t*(-9.903864626381598e-05);y=0.2599984711995416+t*(0.00999950955530049); label=1;}
border branch0connection27(t=0, 1){x=1.4993115602622034+t*(-0.0001102280345539608);y=0.2699979807548421+t*(0.009999392470565305); label=1;}
border branch0connection28(t=0, 1){x=1.4992013322276494+t*(-0.0001267623752598812);y=0.2799973732254074+t*(0.009999196532732957); label=1;}
border branch0connection29(t=0, 1){x=1.4990745698523895+t*(-0.00013044032189246657);y=0.28999656975814037+t*(0.009999149229930726); label=1;}
border branch0connection30(t=0, 1){x=1.498944129530497+t*(-0.0001428784111909831);y=0.2999957189880711+t*(0.009998979235882832); label=1;}
border branch0connection31(t=0, 1){x=1.498801251119306+t*(-0.00015793495906324395);y=0.3099946982239539+t*(0.009998752749653617); label=1;}
border branch0connection32(t=0, 1){x=1.4986433161602428+t*(-0.00016993709852508587);y=0.31999345097360754+t*(0.009998555964865374); label=1;}
border branch0connection33(t=0, 1){x=1.4984733790617177+t*(-0.00018554338579179763);y=0.3299920069384729+t*(0.009998278534427252); label=1;}
border branch0connection34(t=0, 1){x=1.498287835675926+t*(-0.00020217301211200578);y=0.33999028547290017+t*(0.009997956094781268); label=1;}
border branch0connection35(t=0, 1){x=1.498085662663814+t*(-0.00021593226460003834);y=0.34998824156768144+t*(0.00999766839103522); label=1;}
border branch0connection36(t=0, 1){x=1.497869730399214+t*(-0.00023741849671932158);y=0.35998590995871665+t*(0.009997181225596341); label=1;}
border branch0connection37(t=0, 1){x=1.4976323119024946+t*(-0.00025529357402431785);y=0.369983091184313+t*(0.009996740728410558); label=1;}

mesh Th = buildmesh( box0(25) + box1(1) + box2(25) + box3(1) + box4(1) + branch0connection0(1) + branch0connection1(1) + branch0connection2(1) + branch0connection3(1) + branch0connection4(1) + branch0connection5(1) + branch0connection6(1) + branch0connection7(1) + branch0connection8(1) + branch0connection9(1) + branch0connection10(1) + branch0connection11(1) + branch0connection12(1) + branch0connection13(1) + branch0connection14(1) + branch0connection15(1) + branch0connection16(1) + branch0connection17(1) + branch0connection18(1) + branch0connection19(1) + branch0connection20(1) + branch0connection21(1) + branch0connection22(1) + branch0connection23(1) + branch0connection24(1) + branch0connection25(1) + branch0connection26(1) + branch0connection27(1) + branch0connection28(1) + branch0connection29(1) + branch0connection30(1) + branch0connection31(1) + branch0connection32(1) + branch0connection33(1) + branch0connection34(1) + branch0connection35(1) + branch0connection36(1) + branch0connection37(1) );

real buildTime=clock() - buildTime0;
// plot(Th, wait=true);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// TIP INFORMATION
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int nbTips=0; 
real[int] angle(nbTips);
real[int] X(nbTips); 
real[int] Y(nbTips);


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DEFINING PROBLEM AND equation TO SOLVE
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

fespace Vh(Th,P2);
Vh u,v;

problem potential(u,v,solver=sparsesolver)=
         int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v))
             -int1d(Th,3)(v)  // constant flux
			 // +on(3,u=50) // constant field
			 // -int2d(Th)(v) // rain in domain
             +on(1,u=0);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ADAPTING THE MESH AND SOLVING FOR THE FIELD
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        

// counting cells around the tips
real R=0.01; // circle around the tip over which field is integrated
int[int] nvAroundTips = countNvAroundTips (3.*R, Th, Th.nv, nbTips, X, Y);

// First adaptation
real firstAdaptTime0=clock();
// Th = adaptmesh(Th,5.*tipfield(X,Y,3.*R,nbTips),nbvx=500000,nbsmooth=100,iso=true);
Th = adaptmesh(Th,1,nbvx=500000,hmax=0.1,nbsmooth=100,iso=true,ratio=1.8);
real firstAdaptTime=clock() - firstAdaptTime0;
// plot(Th, wait=true);

// Solving the problem for the first time
real firstRunTime0=clock();
potential;
// cout<<"First solve completed."<<endl;
real firstRunTime=clock() - firstRunTime0;

// Adaptation loop
real adaptTime0=clock();
// cout << endl << endl << "Adaptation..." << endl;
fespace Vh0(Th,P0);
Vh0 h=1;
real error=0.02;
int adaptCounter=1;
while(nvAroundTips.min < 250 || adaptCounter<=3)
{
	// cout << "Adaptation step: " << adaptCounter << ", h[].min = " << h[].min;
	// cout << ", nvAroundTip.min = " << nvAroundTips.min << endl;
	potential;
	Th=adaptmesh(Th,[u, 20.*tipfield(X,Y,3.*R,nbTips)],err=error,nbvx=1000000,iso=true,ratio=2,hmin=1e-5);
	error = 0.5*error;
	u=u;
	h=hTriangle; // the triangle size
	nvAroundTips = countNvAroundTips (3.*R, Th, Th.nv, nbTips, X, Y);
	adaptCounter++;
}

// cout << endl << "Adaptation finished." << " h[].min = " << h[].min;
// cout << ", nvAroundTip.min = " << nvAroundTips.min << endl;

// solving with adapted mesh
potential;
// cout << "Problem solved." << endl;
// plot(u, wait=true, fill=true);

real adaptTime=clock() - adaptTime0;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// INTEGRATING THE FIELD TO GET a_i COEFFICIENTS
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////        
real coeffTime0=clock();
// cout << endl << endl << "Finding the Tip coefficients..." << endl;

mesh Ph;
real[int] a(3); // list of coefficients of the expansion
int exponant=2; // precision of the exponential
// ofstream freefemOutput("{file_name}");

cout << "kopytko ";
for(int i=0;i<nbTips;++i)
{
    // cout << "Processing Tip " << i << " ";   
    x0=X(i);y0=Y(i);
    // cout << "(x0, y0) = (" << x0 << ", " <<y0<< "), angle = " << angle(i) << endl;

	// cout << "Projecting... Th.nv = " << Th.nv;
    Ph=trunc(Th,(sqrt((x-x0)^2+(y-y0)^2) < 3*R)); 
	// cout << ", Ph.nv = " << Ph.nv << endl;

    for(int order=1; order<=a.n; ++order){ 
        a[order-1]=
        int2d(Ph)( u*exp(-(sqrt((x-x0)^2 + (y-y0)^2)/R)^exponant)
		*BaseVector(order,exp(-angle(i)*1i)*( (x-x0) + (y-y0)*1i) ) ) /
        (int2d(Ph)(exp(-(sqrt((x-x0)^2 + (y-y0)^2)/R)^exponant)
		*square(BaseVector(order,exp(-angle(i)*1i)*( (x-x0) + (y-y0)*1i) ) )));

		cout << a[order-1] << ",";
        // cout << "a(" << order << ") = " << a[order-1] << endl;
    }
	// freefemOutput << Th.nv << " ";
	// freefemOutput << Ph.nv << " ";
	// freefemOutput << adaptCounter << " ";

	// cout << endl;
};

// cout << endl << endl << "Building mesh took: " << buildTime; 
// cout << endl << "First adapt took: " << firstAdaptTime; 
// cout << endl << "First run took: " << firstRunTime; 
// cout << endl << "Adaptation took: " << adaptTime; 
// cout << endl << "Calculating coefficients took: " << clock()- coeffTime0;
// cout << endl << "Total time: " << clock()-time0 << endl << endl;
